# -*- coding: utf-8 -*-
"""
Implementing a wrapper for a new engine SHARC:
https://sharc-md.org

Created on Thu Oct  1 10:24:54 2020

@author: Madlen Maria Reiner
"""

import logging # debugging etc.
logger = logging.getLogger(__name__)
import copy # shallow/deep copy operations

from mdtraj.formats import TRRTrajectoryFile
import mdtraj as md

import numpy as np
import os

from openpathsampling.engines import DynamicsEngine, SnapshotDescriptor
# DynamicsEngine in dynamics_engine.py -> wraps simulation tool
# SnapshotDescriptor in dynamics_engine.py -> Container for information about
# snapshots generated by an engine.

#from openpathsampling.engines.openmm.snapshot import Snapshot
# TODO: brauche Ordner Snapshot oder verweise auf Pfad zu OpenMM snapshot?
from openpathsampling.engines.sharc.snapshot import SharcSnapshot as SharcSnapshot

import openpathsampling.engines.openmm as omm
# um die trajektorie zu laden

from openpathsampling.engines.external_snapshots import ExternalMDSnapshot

# def snapshot_from_sharc(sharc_files, template):
#     class SharcFileEngine(ExternalEngine, template):
#         def __init__(self, sharc_file, template):
#             mdt = md.load('output.xyz', top='H2.pdb')
#             self.topology = MDTrajTopology(mdt.topology)
#             n_atoms = self.topology.n_atoms
#             n_spatial = self.topology.n_spatial
#             print(n_spatial)
#             #print(mdt.n_atoms)
#             #print(mdt.xyz[0])
#             # next two lines create numpy array for velocities (JUST EXAMPLE)
#             # http://openpathsampling.org/latest/topics/simulation_setup.html
#             trr = md.formats.TRRTrajectoryFile("trajectory_file.trr")
#             vel = trr._read(n_frames=len(mdt), atom_indices=None, get_velocities=True)[5]
#             # combine `mdt` and `vel` in an OPS trajectory
#             traj = omm.trajectory_from_mdtraj(mdt, velocities=vel)
#         #return traj

class SharcEngine(DynamicsEngine):
    """
    Engine wrapper for SHARC.
    
    TODO: more information.
    """
    
    _default_options = {
        'integ' : None,
        'n_steps_per_frame': 10,
        'n_frames_max' : 5000
    }
    
    base_snapshot_type = SharcSnapshot
    
    def __init__(self, topology, options=None):
        """
        

        Parameters
        ----------
        topology : TYPE
            DESCRIPTION.
        options : TYPE, optional
            DESCRIPTION. The default is None.

        Returns
        -------
        None.

        """
        if 'n_spatial' not in options:
            options['n_spatial'] = topology.n_spatial

        options['n_atoms'] = 2

        snapshot_dimensions = {
            'n_atoms': topology.n_atoms,
            'n_spatial': topology.n_spatial
        }

        descriptor = SnapshotDescriptor.construct(
            snapshot_class=SharcSnapshot,
            snapshot_dimensions=snapshot_dimensions
        )

        super(SharcEngine, self).__init__(
            options=options,
            descriptor=descriptor
        )

        self.topology = topology

        self._current_snapshot = None
        # self._current_momentum = None
        # self._current_configuration = None
        # self._current_box_vectors = None

        # self._simulation = None
        
    @property
    def n_steps_per_frame(self):
        return self.options['n_steps_per_frame']
        
    @n_steps_per_frame.setter
    def n_steps_per_frame(self, value):
        self.options['n_steps_per_frame'] = value
        
    @property
    def current_snapshot(self, path_to_files=""):
        """
        This is a function that extracts features from engine files and
        converts them to OPS SharcSnapshot.

        Parameters
        ----------
        path_to_files : str, optional
            Option if we do not work in current directory. The default is "".

        Returns
        -------
        SharcSnapshot
            See /engines/sharc/snapshot.

        """
        with open(path_to_files+'restart.traj', 'r') as file:
            pos = False
            vel = False
            positions = []
            velocities = []
            for i, line in enumerate(file):
                if i == 2:
                    n_atoms = np.int(line)
                    # actually, this is not needed
                elif i == 3:
                    num_pes = np.int(line) # number of current PES
                if not pos:
                    if 'Geometry' in line:
                        pos = True
                elif 'Velocity' in line:
                    pos = False
                else:
                    np_pos = [float(x) for x in line.split()]
                    positions.append(np_pos) # read positions (=coordinates)
                if not vel:
                    if 'Velocity' in line:
                        vel = True
                elif 'Acceleration' in line:
                    break
                else:
                    np_vel = [float(x) for x in line.split()]
                    velocities.append(np_vel) # read velocities
        
        # this reads the tmax from restart.ctrl
        f = open(path_to_files+"restart.ctrl", 'r')
        lines = f.readlines()
        tmax = np.int(lines[8])
        f.close()
        
        #copy restart.traj to restart_tmax.traj
        # os.system("cp "+path_to_files+"restart.traj "+path_to_files \
        #           +"restart_"+'{:000000000010d}'.format(tmax)+".traj")
        
        if os.path.exists("check.current_snapshot.getter"):
            pass
        else:
            #copy restart.traj to the end of restart_files.traj
            restart_files = open(path_to_files+"restart_files.traj", 'a')
            restart = open(path_to_files+"restart.traj", 'r')
            restart_files.write(restart.read())
            # create check file
            os.system("touch check.current_snapshot.getter")        
        
        return SharcSnapshot(
            coordinates=np.array(positions),
            velocities=np.array(velocities),
            num_pes=num_pes,
            tmax=tmax,
            engine=self
        )
    
    @current_snapshot.setter
    def current_snapshot(self, snap, path_to_files=""):
        """
        This function takes the OPS features of any snapshot 'snap' and
        writes it to the restart files such that SHARC can understand them.

        Parameters
        ----------
        snap : SharcSnapshot
            See /engines/sharc/snapshot.
        path_to_files : str, optional
            Option if we do not work in current directory. The default is "".

        Returns
        -------
        None.

        """
        self.check_snapshot_type(snap)
        #coords = np.copy(snap.coordinates)
        tmax = snap.tmax
        vels = snap.velocities
        
        # os.system("cp "+path_to_files+"restart_" \
        #           +'{:000000000010d}'.format(tmax)+".traj " \
        #           +path_to_files+"restart.traj")
        restart_length = len(open(path_to_files+"restart.traj", 'r').readlines())
        first = restart_length*tmax + 1
        last = restart_length*tmax + restart_length
        os.system(r"awk 'NR>"+str(last)+r"{exit}NR>="+str(first)+r"{print $0 > "+r'"restart.traj"'+r"}' restart_files.traj")
        
        # modify restart.traj with parameters from OPS
        f = open(path_to_files+"restart.traj", 'r')
        lines = f.readlines()
        f.close()
        n = 0
        for l in lines:
            if (l=='Velocity\n'):
                veloc_line=n
            if (l=='Acceleration\n'):
                accel_line=n
                break
            n+=1
        # this
        natoms=accel_line-veloc_line-1
        for i in range(natoms):
            lines[veloc_line+i+1]=''
            for d in range(3):
                lines[veloc_line+i+1]+='{:.16E}  '.format(vels[i,d])
            lines[veloc_line+i+1]=lines[veloc_line+i+1].strip()+'\n'
        #lines[6] = "{:12d}\n".format(t)
        f = open(path_to_files+"restart.traj", 'w')
        f.writelines(lines)
        f.close()
    
    def generate_next_frame(self, path_to_files=""):
        """
        This function increases the value of feature tmax by n_steps_per_frame
        in restart.ctrl, sets the value of feature tmax in restart.traj,
        and generates the next frame by running $SHARC/input.sh.

        Parameters
        ----------
        path_to_files : str, optional
            Option if we do not work in current directory. The default is "".

        Returns
        -------
        SharcSnapshot
            See /engines/sharc/snapshot.

        """
        os.system("cd "+path_to_files)
        
        f = open(path_to_files+"restart.ctrl", 'r')
        lines = f.readlines()
        tmax = np.int(lines[8])
        lines[8] = "{:12d}\n".format(tmax+1)
        f.close()
        f = open(path_to_files+"restart.ctrl", 'w')
        f.writelines(lines)
        f.close()
        f = open(path_to_files+"restart.traj", 'r')
        lines = f.readlines()
        lines[6] = "{:12d}\n".format(tmax+1-self.n_steps_per_frame)
        f.close()
        f = open(path_to_files+"restart.traj", 'w')
        f.writelines(lines)
        f.close()
        
        os.system("rm -f check.current_snapshot.getter")
        
        os.system("sh run.sh")
        
        return self.current_snapshot
    
    def to_dict(self):
        #system_xml = simtk.openmm.XmlSerializer.serialize(self.system)
        #integrator_xml = simtk.openmm.XmlSerializer.serialize(self.integrator)
        return {
        #    'system_xml': system_xml,
        #    'integrator_xml': integrator_xml,
            'topology': self.topology,
            'options': self.options,
        #    'properties': self.openmm_properties
        }

    @classmethod
    def from_dict(cls, dct):
        #system_xml = dct['system_xml']
        #integrator_xml = dct['integrator_xml']
        topology = dct['topology']
        options = dct['options']
        #properties = dct['properties']

        # we need to have str as keys
        #properties = {str(key): str(value)
        #              for key, value in properties.items()}

        #integrator = simtk.openmm.XmlSerializer.deserialize(integrator_xml)
        #integrator = restore_custom_integrator_interface(integrator)
        return SharcEngine(
            topology=topology,
            #system=simtk.openmm.XmlSerializer.deserialize(system_xml),
            #integrator=integrator,
            options=options,
            #openmm_properties=properties
        )